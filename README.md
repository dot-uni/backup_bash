# backup_bash
bash script that creates backup copies of projects

# Реализация
Вся реализация написана в файле `backup.sh`.
### Начало файла
- В самом вверху файла можно увидеть следующий код:
`#!/bin/bash` - указывает системе каким интерпретатором выполнять файл 
`set -euo pipefail` - строка, которая состоит из 3-ех флагов, которая делает написанный код безопасней. 
- `set -e` - скрипт немедленно завершается, если любая команда вернула ненулевой код.
- `set -u` - вызывается ошибка, если используется переменная, которой не существует.
- `set -o` - Если любая команда в пайпе упала — весь пайп считается ошибкой. 
### Блок конфигураций
> В данном поле объявляются глобальные переменные, которые будут использоваться программой для создания бэкапа:

- `DATA=""` - путь к файлу или директории, которую нужно резервно копировать. Указывается, после разбора аргументов входных данных.

- `BACKUP_ROOT=""` - имя корневой директории для всех бэкапов конкретного источника. Формируется как `BACKUP_ROOT="$(basename "$DATA")_backups"`, где `$(basename "$DATA")` - имя файла или директории, которую будем резервно копировать. Позволяет хранить бэкапы разных источников отдельно и избежать конфликтов имён.

- `PATH_BACKUP_DIR="$HOME"` - базовая директория, где будут храниться все бэкапы. По умолчанию: `$HOME`. Переопределяется: через `-d / --directory`. Позволяет гибко выбрать место хранения бэкапов (локальный диск, внешний, сетевой).

- `MODE="incremental"` - режим резервного копирования. Задается через `-m / --mode`.
	Допустимые значения:
	- *full* — полная копия
	- *incremental* — инкрементальная (через hard links)
	- *mirror* — зеркало (с удалением файлов)

- `ARCHIVE=false` - флаг, который включает архивацию. Устанавливается через `-c[1-9] / -cz[1-9] / -cj[1-9] / -cJ[1-9]`. Где:
	- `-c` - включить архивацию бэкапа с помощью tar, без сжатия.
	- `-cz` - архивировать и сжать с помощью gzip.
	- `-cj` - архивировать и сжать с помощью bzip2.
	- `-cJ` - архивировать и сжать с помощью xz (LZMA).
	- `[1-9]` - уровень сжатия(`COMPRESS_LEVEL`), можно не указывать явно и использовать значение по умолчанию.

- `COMPRESS_FLAG=""` - тип сжатия для tar. Значения:
	- z → gzip
	- j → bzip2
	- J → xz

- `COMPRESS_LEVEL=""` - уровень сжатия (1–9). Позволяет контролировать компромисс _скорость ↔ размер_.

- `RETENTION_DAYS=14` - сколько дней хранить старые бэкапы. Его роль автоматически очищать и защищать от переполнения диска.

- `HOST="$(hostname)"` - имя текущей машины. Создается папка с этим названием, в которой будут храниться все бэкапы(`.../$BACKUP_ROOT/$HOST/`). Позволяет использовать один backup-каталог для нескольких машин.

- `DATE="$(date +"%Y-%m-%d_%H-%M-%S")"` - метка времени, когда создана конкретная версия бэкапа. Используется для имени каталога бэкапа и имени соответствующего лог файла. Использование даты для создании файлов гарантирует уникальность и упорядоченность.

- `LATEST_LINK=""` - символическая ссылка на последний успешный бэкап(`.../$BACKUP_ROOT/$HOST/latest"`). Используется в incremental-режиме (`--mode=incremental / -m incremental / ...`) и для удобства навигации.

- `LOG_DIR=""` - каталог логов(`.../log/`), в котором хранятся логи соответствующих бэкапов.

- `CUR_BACKUP=""` - полный путь к текущему бэкапу(`.../$BACKUP_ROOT/$HOST/backup_$DATE"`), например:
	`/Users/user/pr_backups/MacBook-Pro.local/backup_2025-12-24_23-34-27`.

- `LATEST_LINK=""` - хранится путь к символической ссылке latest, указывающей на последний успешный бэкап(`.../$BACKUP_ROOT/$HOST/latest"`).
- `LOG_FILE=""` - файл лога конкретного запуска.
### Блок функций 
> Блок FUNCTIONS содержит набор вспомогательных и рабочих функций, реализующих проверку входных данных, подготовку среды, выполнение резервного копирования, архивацию, очистку старых данных и логирование, что обеспечивает модульность и читаемость сценария.
#### usage()
 Выводит справку по использованию программы:
- синтаксис запуска
- аргументы
- опции
- примеры
- предупреждения
Вызывается при ошибках парсинга аргументов. Можно явно вызвать при помощи флагов `-h / --help`.

#### log()
Одновременно выводит состояние программы в stdout и в лог-файл(`LOG_FILE`). Удобно, чтобы отлаживать программу в случаи ошибки.

#### fatal()
Логирует ошибку и завершает программу с ненулевым кодом. Используется при фатальных ошибках, в `check_requirements()` и при сбоях архивации и создания каталогов.

#### validate_directory()
Проверяет корректность каталога:
1. допустимые символы пути
2. существование
3. права на запись

#### validate_data()
Проверяет, что объект для бэкапа существует и доступен для чтения. Не начинать бэкап несуществующего файла/директории.

#### init_directories()
Создаёт **всю структуру каталогов**:
- корень бэкапов;
- каталог хоста;
- каталог текущего бэкапа;
- каталог логов.
Особенность: если вдруг так совпало, что мы решили бэкапить два одинаковых файла/директории одновременно оба попытаются создать один и тот же каталог(`CUR_BACKUP`), потому что время создания бэкапа будет совпадать. В результате:
- Один процесс создаст каталог
- Второй упадёт на mkdir → fatal.
Так как функция `init_directories()` вызывается самой первой в процессе создания резервной копии, никак не изменяются состояния старых бэкапов, не портится ссылка на последний работающий бэкап(`LATEST_LINK`) и также не портится бэкап, который был создан первым процессом. В данной функции мы избегаем появления race condition.

#### check_requirements()
Проверяет наличие необходимых утилит. Проверяется перед началом работы.

#### backup_rsync()
Реализует основную логику резервного копирования через rsync. Режимы:
1. *full* - копирует весь каталог или файл `DATA` полностью в новый каталог бэкапа (`CUR_BACKUP`). Каждый раз создаётся полный снимок данных.
	Плюсы: 
	- Простота
	- Можно быстро восстановить любой бэкап
	Минусы
	- Занимает много места
	- Долго копируется при больших данных

2. *mirror* - копирует все файлы из `DATA` в `CUR_BACKUP` как в full. Опция `--delete` удаляет из бэкапа файлы, которых нет в источнике. Результат: зеркальное соответствие источника. Пример:
```c
Исходник: file1, file2
Старый бэкап: file1, file2, file3
После mirror: file1, file2
```
	file3 удаляется из бэкапа, потому что его нет в DATA.
Плюсы
- Всегда актуальное состояние данных
Минусы
- Может удалить файлы, если они случайно удалены в источнике

3. *incremental* - копирует только изменённые файлы с момента последнего бэкапа. Не изменённые файлы создаются как hard links на предыдущий бэкап (latest). В итоге все бэкапы выглядят как полные, но на диске фактически экономят место.
	Плюсы
	- Экономит место
	- Можно быстро делать ежедневные бэкапы
	Минусы
	- Зависит от предыдущих бэкапов (latest)    
	- Если старый бэкап повреждён — hard links будут ссылаться на повреждённые файлы

#### update_latest()
- ln — создать ссылку
- -s — символическая ссылка
- -f — принудительно удалить существующий файл/ссылку
- -n — если LATEST_LINK уже является символической ссылкой, не следовать за ней
- В итоге: старый latest удаляется (если есть) и создаётся новая ссылка на `CUR_BACKUP`
Выполняется после успешного выполнения `backup_rsync()`. Используется для поддержки incremental-режима и удобной навигации. Так как все действия выполняются одной командой, то нету промежутков между удалением и созданием ссылки, где другой процесс мог бы вмешаться. В результате нет повреждений данных и latest указывает на один из двух бэкапов.

#### archive_backup()
Если включён флаг -c (`ARCHIVE="true"`), то архивирует текущий бэкап с помощью tar:
- без сжатия;
- gzip;
- bzip2;
- xz;
- с уровнями сжатия.

#### cleanup_old()
Удаляет старые бэкапы по политике хранения.

#### summary()
Выводит итоговый отчёт о запуске. 

### Парсинг входных параметров, подготовка необходимых данных для бэкапа
#### Разбор аргументов 
```c
while [[ $# -gt 0 ]]; do
    case "$1" in 
        --*) 
            # обработка длинных опций
            ...
        -?*) 
            # обработка коротких флагов
            ...
        *)
            break
            ;;
    esac
done
```
- case разделяет:
    - `--*` — длинные опции (--directory, --mode, --help)
    - `-?* `— короткие флаги (-d, -m, -c, -h)
    - `*` — это не опция → значит передан путь `DATA` для бэкапа

#### Проверка обязательного аргумента DATA
- Проверяем, что передан файл или директория для бэкапа
- Проверяем, что существует и доступна для чтения (validate_data)
- Присваиваем переменной DATA

#### Инициализация путей 
После того, как окончательно установлен путь до директории где будут храниться все бэкапы (`PATH_BACKUP_DIR`), мы инициализируем оставшиеся пути.
### Блок Main. Алгоритм работы программы
Основная часть программы, которая задает такой алгоритм работы по созданию резервной копии файла/директории:
1. Проверка установленных команд (`check_requirements()`)
2. Создание каталогов для бэкапов и логов (`init_directories()`)
3. Копирование данных (`backup_rsync()`) в зависимости от режима
4. Обновление символической ссылки latest (`update_latest()`)
5. Архивирование бэкапа (если включено `COMPRESS`) (`archive_backup()`)
6. Удаление старых бэкапов (`cleanup_old()`)
7. Вывод итогов работы (`summary()`)

   
# Тестирование 
Для тестирования создан файл `tests.py`, который:
1. Создаёт случайные файлы в папке `./test_data/`
2. Делает архивацию, со сжатием(`-cz / -cj / -cJ`) и без(`-c`).
3. Делает full backup
4. Делаeт incremental backup, создаёт новый файл
5. Делаeт mirror backup, удаляет файл из исходника
6. Проверка того, что программа ловит бэкапы одних и тех же файлов/директорий, которые имеют одинаковое название. И в результате прошлые бэкапы и latest сохраняют свое состояние.

   
# Автоматизация
Автоматизировать работу по созданию резервных копий файлов/директорий можно с помощью `cron`
1. Выполняем:
	`crontab -e`
2. Формат записи:  * * * * * _Полный_Путь_До_Backup.sh_   _Указываем_Необходимые_Аргументы  Указываем_Полный_Путь_До_Файла/Директории_
К примеру, мы хотим, чтобы наш создание резервной копии происходила каждую минуту:
	`*/5 * * * *  /Users/iam/projects/scripts/backup.sh -cj9 /Users/iam/projects/some_dir`

